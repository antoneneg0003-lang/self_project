# üèÜ COMPLETE COMPETITIVE PROGRAMMING MASTER LIST
(Organized strictly by your template. Exhaustive coverage.)

------------------------------------------------------------

# Programming_Language (Python)

- Fast I/O (sys.stdin, sys.stdout)
- Recursion limits
- Iterative DFS/BFS patterns
- Built-in data structures
- heapq
- bisect
- itertools
- functools (lru_cache)
- math module
- fractions
- decimal
- random
- collections (deque, defaultdict, Counter)
- Bit manipulation
- List comprehensions
- Lambda functions
- Custom sorting
- PyPy vs CPython considerations
- Time profiling awareness
- Memory optimization awareness

------------------------------------------------------------

# Data_structure

## Linear
- Array
- Dynamic Array
- Stack
- Queue
- Deque
- Circular Queue
- Linked List (conceptual)
- Doubly Linked List (conceptual)

## Hash-Based
- Hash Table
- Set
- Multiset (simulation)
- Ordered Set
- Ordered Map
- Frequency Map

## Tree-Based
- Binary Tree
- Binary Search Tree
- AVL Tree
- Red-Black Tree
- Treap
- Splay Tree
- Cartesian Tree
- B-Tree (concept)
- Trie
- Persistent Trie
- Radix Trie
- Segment Tree
- Lazy Segment Tree
- Persistent Segment Tree
- Dynamic Segment Tree
- Segment Tree Beats
- Fenwick Tree (BIT)
- 2D Fenwick Tree
- Sparse Table
- Disjoint Sparse Table
- Sqrt Decomposition
- Heavy-Light Decomposition
- Centroid Decomposition
- Link-Cut Tree
- Euler Tour Tree
- Li Chao Tree
- KD-Tree
- Interval Tree
- Order Statistics Tree
- Wavelet Tree
- Merge Sort Tree
- Persistent Array
- Rope

## Disjoint Structures
- Disjoint Set Union
- Union by Rank
- Path Compression
- Rollback DSU
- Persistent DSU

## Graph Representations
- Adjacency List
- Adjacency Matrix
- Edge List
- Compressed Sparse Row
- Implicit Graph

------------------------------------------------------------

# Paradigms

- Brute Force
- Greedy
- Divide & Conquer
- Dynamic Programming
- Backtracking
- Recursion
- Bitmasking
- Meet in the Middle
- Two Pointers
- Sliding Window
- Binary Lifting
- State Compression
- Offline Processing
- Interactive Problems
- Constructive Algorithms
- Game Modeling
- Graph Modeling
- Mathematical Modeling
- Randomized Algorithms
- Reduction
- Flow Modeling
- Geometry Modeling
- Parametric Search
- Small-to-Large Merging
- Rerooting Technique
- Inclusion-Exclusion Principle Application

------------------------------------------------------------

# Strategies

- Pattern Recognition
- Constraint Analysis First
- Edge Case Enumeration
- Observation Extraction
- Problem Reduction
- Transform to Graph
- Transform to DP
- Transform to Math
- Binary Search on Answer
- Greedy Choice Justification
- Casework
- Invariant Tracking
- Symmetry Usage
- Complement Counting
- Reverse Thinking
- Simulation Simplification
- Proof Before Coding
- Time Allocation Strategy
- Upsolving Strategy

------------------------------------------------------------

# Tools

- Prefix Sum
- Difference Array
- Coordinate Compression
- Binary Lifting Tables
- Euler Tour Flattening
- Sweep Line
- Monotonic Stack
- Monotonic Queue
- Convex Hull Trick
- Li Chao Tree
- Mo‚Äôs Algorithm
- Offline Query Processing
- Bitset Optimization
- Precomputation
- Memoization
- Tabulation
- Random Shuffle
- Fast Exponentiation
- Matrix Exponentiation
- Stress Testing
- Template Library

------------------------------------------------------------

# Techniques

- Binary Search
- Ternary Search
- Parametric Search
- Meet in the Middle
- SOS DP
- Digit DP
- Profile DP
- Rerooting DP
- Tree DP
- Divide & Conquer Optimization
- Knuth Optimization
- Convex Hull Optimization
- CDQ Divide & Conquer
- Small-to-Large Merging
- Bit Tricks
- Invariant Arguments
- Greedy Exchange Argument
- Casework Splitting
- Sliding Window Optimization
- Prefix/Suffix Technique

------------------------------------------------------------

# Methods

- Induction
- Contradiction
- Pigeonhole Principle
- Parity Arguments
- Invariant Method
- Extremal Principle
- Constructive Proof
- Reduction
- Recurrence Solving
- Generating Functions
- Matrix Recurrence
- Binary Exponentiation
- Randomization
- Approximation Methods
- Heuristics (Simulated Annealing)

------------------------------------------------------------

# Algorithms

## Searching & Sorting
- Linear Search
- Binary Search
- Ternary Search
- Exponential Search
- Bubble Sort
- Selection Sort
- Insertion Sort
- Merge Sort
- Quick Sort
- Heap Sort
- Counting Sort
- Radix Sort
- Bucket Sort

## Graph Algorithms
- BFS
- DFS
- 0-1 BFS
- Multi-source BFS
- Bidirectional BFS
- Dijkstra
- Bellman-Ford
- SPFA
- Floyd-Warshall
- Johnson‚Äôs Algorithm
- A*
- Kruskal
- Prim
- Boruvka
- Topological Sort
- Kosaraju SCC
- Tarjan SCC
- Bridges
- Articulation Points
- Biconnected Components
- Eulerian Path
- Hamiltonian Path (DP)
- Bipartite Check
- Hopcroft-Karp
- Blossom Algorithm
- Ford-Fulkerson
- Edmonds-Karp
- Dinic
- Push-Relabel
- Min Cost Max Flow
- Circulation with Demands
- Hungarian Algorithm
- Stoer-Wagner Min Cut
- Gomory-Hu Tree
- LCA (Binary Lifting)
- LCA (RMQ)
- Tree Diameter
- Tree Centroid
- Virtual Tree
- Dominator Tree
- Dynamic Connectivity

## Dynamic Programming
- 1D DP
- 2D DP
- 3D DP
- Bitmask DP
- Digit DP
- Tree DP
- DAG DP
- Rerooting DP
- Knapsack Variants
- Subset Sum
- LIS
- Edit Distance
- Matrix Chain Multiplication
- Knuth Optimization
- Divide & Conquer DP
- Monotonic Queue Optimization
- SOS DP
- Profile DP
- Probability DP
- Expected Value DP

## String Algorithms
- KMP
- Z Algorithm
- Rabin-Karp
- Rolling Hash
- Double Hashing
- Manacher
- Suffix Array
- LCP Array
- Kasai
- Suffix Automaton
- Aho-Corasick
- Booth‚Äôs Algorithm
- Lyndon Decomposition
- Palindromic Tree (Eertree)

## Computational Geometry
- Orientation Test
- Cross/Dot Product
- Line Intersection
- Segment Intersection
- Distance Calculations
- Convex Hull (Graham)
- Convex Hull (Monotone Chain)
- Rotating Calipers
- Closest Pair of Points
- Half Plane Intersection
- Polygon Area (Shoelace)
- Point in Polygon
- Pick‚Äôs Theorem
- Circle-Line Intersection
- Circle-Circle Intersection
- Tangents
- Minkowski Sum
- KD-Tree Nearest Neighbor
- Delaunay (concept)
- Voronoi (concept)

## Advanced Algorithms
- FFT
- NTT
- Karatsuba
- Strassen
- Gaussian Elimination
- Fast Walsh-Hadamard Transform
- Pollard Rho
- Miller-Rabin
- Baby-Step Giant-Step
- Mo‚Äôs Algorithm
- Meet in the Middle
- Bitset Tricks
- Simulated Annealing

------------------------------------------------------------

# Math (all)

## Number Theory
- Prime Numbers
- Sieve
- Segmented Sieve
- GCD / LCM
- Extended Euclid
- Modular Arithmetic
- Modular Inverse
- Fermat‚Äôs Theorem
- Euler‚Äôs Theorem
- Totient Function
- Chinese Remainder Theorem
- Diophantine Equations
- Lucas Theorem
- Wilson‚Äôs Theorem
- Mobius Function
- Primitive Roots
- Discrete Logarithm
- Divisor Function
- Multiplicative Functions

## Combinatorics
- Permutations
- Combinations
- Stars and Bars
- Catalan Numbers
- Stirling Numbers
- Bell Numbers
- Binomial Theorem
- Generating Functions
- Burnside Lemma
- Polya Counting
- Derangements
- Inclusion-Exclusion

## Discrete Math
- Graph Theory
- Pigeonhole Principle
- Invariants
- Parity
- Recurrence Relations
- Linear Recurrence
- Set Theory
- Relations
- Equivalence Classes

## Probability
- Expected Value
- Variance
- Linearity of Expectation
- Conditional Probability
- Bayes Theorem
- Random Variables
- Distributions (Binomial, Geometric)

## Linear Algebra
- Matrix Multiplication
- Matrix Exponentiation
- Determinant
- Gaussian Elimination
- Vector Spaces

## Game Theory
- Nim
- Grundy Numbers
- Sprague-Grundy
- Mex Function
- Impartial Games
- Mis√®re Nim

------------------------------------------------------------

# Problem_Modeling

- Translate story ‚Üí formal model (variables, constraints, objective)
- Constraint extraction (n, q, value ranges, time/memory limits)
- Input-output structure identification (single test / multi test / online)
- Choose representation:
  - Graph model (nodes/edges/states)
  - Tree model (rooting, parent-child, LCA needs)
  - Grid model (4/8-neighbor, weighted/unweighted)
  - State graph model (BFS/DP over states)
  - Interval model (events, segments, ranges)
  - String model (pattern matching / automaton)
  - Geometry model (points/segments/polygons)
  - Flow model (supply/demand/capacity/cost)
  - Matching model (bipartite/general)
  - Scheduling model (intervals, deadlines)
  - Counting model (combinatorics/mod arithmetic)
- Identify monotonicity/convexity (for binary search / CHT)
- Identify invariants (parity, conservation, monotone measure)
- Identify symmetry / equivalence classes
- Identify decomposition:
  - Connected components / SCC condensation
  - Tree decomposition (centroid/HLD)
  - Divide & conquer split
  - DP state factorization
- Decide online vs offline approach
- Decide constructive vs decision vs optimization formulation
- Reverse modeling (solve for output constraints ‚Üí required structure)
- Multi-step modeling (reduce to subproblems with interfaces)

------------------------------------------------------------

# Proof_Techniques

- Direct proof
- Proof by contradiction
- Proof by induction
  - Simple induction
  - Strong induction
  - Structural induction (trees/graphs)
- Invariants
- Monovariants (strictly increasing/decreasing measure)
- Extremal principle (take minimal/maximal counterexample)
- Parity arguments
- Pigeonhole principle
- Exchange argument (greedy correctness)
- Cut-and-paste argument (greedy/matching)
- Local optimality ‚Üí global optimality arguments
- Optimal substructure justification (DP)
- Loop invariants (implementation correctness)
- Potential method (amortized analysis)
- Coupling arguments (probability, rare)
- Double counting
- Bijective proofs (combinatorics)
- Inclusion‚Äìexclusion reasoning proof style
- Graph cut arguments (min-cut/max-flow)
- Matroid greedy proof schema (advanced)
- Dominance arguments (DP optimizations)
- Feasibility + minimality proof (constructive)
- Uniqueness proof (when needed)
- Bounds proofs (upper/lower bounds)

------------------------------------------------------------

# Optimizations

## Time Optimizations
- Precomputation tables
- Memoization / caching
- Pruning in search/backtracking
- Meet-in-the-middle to reduce exponent
- Bitset optimization
- Use of prefix/suffix aggregates
- Two pointers / sliding window to reduce nested loops
- Hashing to reduce comparisons
- Coordinate compression
- Offline query processing
- Mo‚Äôs algorithm
- CDQ divide & conquer (offline dominance / DP)
- Small-to-large merging (DSU on tree)
- Rerooting reuse
- Fast exponentiation / exponentiation by squaring
- Matrix exponentiation for linear recurrences
- NTT/FFT for polynomial convolution speedups
- Convex Hull Trick optimization
- Li Chao tree optimization
- Knuth optimization
- Divide & conquer DP optimization
- Monotone queue / monotone stack optimization
- Dial‚Äôs algorithm (small integer weights)
- 0-1 BFS (0/1 weights)
- Sparse table for O(1) RMQ
- Binary lifting for jumps
- Heavy-light decomposition for path queries
- Centroid decomposition for distance queries
- Persistent DS for query versioning

## Memory Optimizations
- Rolling arrays in DP
- Compress DP states
- Bitmask compression
- Store only needed layers/levels
- Use arrays instead of dicts when possible
- Coordinate compression to reduce memory
- Custom struct packing (conceptual; in python: tuples vs objects)
- Avoid recursion stack (iterative)
- Reuse buffers

## Implementation / Practical Optimizations
- Fast I/O patterns
- Local variable binding (Python micro-opt)
- Avoid heavy object allocation in loops
- Use integer arithmetic over floating where possible
- Preallocate lists
- Use PyPy when it helps (but test performance)
- Stress testing (random + brute force validator)
- Deterministic seeds for reproducibility

------------------------------------------------------------

# Complexity_Theory

- Big-O, Big-Theta, Big-Omega
- Worst-case / average-case / expected-case
- Amortized analysis
  - Aggregate method
  - Accounting method
  - Potential method
- Recurrence solving
  - Master theorem
  - Recursion tree method
- Complexity classes (awareness)
  - P, NP, co-NP
  - NP-hard, NP-complete
- Reductions
  - Polynomial-time reductions
  - Transformations between known problems
- Lower bounds (comparison sort lower bound, decision tree)
- Pseudopolynomial vs polynomial
- Parameterized complexity (FPT, kernelization) (rare but exists in CP)
- Approximation awareness (rare)
- Randomized complexity (Las Vegas / Monte Carlo)
- Online vs offline complexity considerations
- Input size scaling + constant factors
- Cache friendliness (more relevant in C++ but conceptually useful)

------------------------------------------------------------

# Specialized_Domains

- Graph Theory (advanced subtopics)
  - SCC, BCC, bridges/articulation, dominator tree (rare)
  - Flow variants, matching, min-cut
  - Tree algorithms (LCA, HLD, centroid, rerooting)
  - Planar graphs (rare)
  - Dynamic graphs (offline connectivity)
- String Theory / String Algorithms
  - Automata (Aho-Corasick, suffix automaton)
  - Suffix structures (suffix array/LCP)
  - Hashing / string DP
- Computational Geometry
  - Robust predicates, convex hull, intersections, sweepline
  - Rotating calipers, Minkowski sum, half-plane intersection
- Number Theory
  - Modular arithmetic, primes, CRT, discrete log, factorization
- Combinatorics
  - Counting, generating functions, inclusion-exclusion, Polya/Burnside
- Game Theory
  - Nim, Grundy, mex, mis√®re games, game DP
- Probability
  - Expected value, distributions, Markov chains, randomized methods
- Linear Algebra
  - Gaussian elimination, matrix exponentiation, determinants
- Polynomial / Formal Power Series
  - FFT/NTT, convolution, polynomial ops (advanced)
- Optimization / DP Optimization
  - CHT, Li Chao, Knuth, D&C optimization
- Interactive / Adversarial problems
  - Query strategy, information theory style reasoning
- Bitwise / XOR algebra
  - Linear basis over GF(2), xor convolution (FWT)

------------------------------------------------------------

# CP_Specific_Things

- Fast input-output handling
- Multiple test case patterns
- Constraints-first design habit
- Precision handling (eps, integer geometry)
- Overflow handling (64-bit thinking)
- Mod arithmetic discipline (mod inverse, negative mod)
- Edge case discipline (n=0/1, duplicates, extremes)
- Template/library management
- Stress testing + brute force checker
- Hack-resistant hashing (mainly C++; python: still relevant concept)
- Time limit awareness (constant factors)
- Memory limit awareness
- Debug under pressure (print guards, assertions)
- Interactive protocol discipline (flush, query limits)
- Output formatting exactness
- Reading/editorial synthesis skill
- Upsolving workflow
- Problem tagging + spaced repetition revision
- Maintain ‚Äúwrong answers‚Äù notebook (failure patterns)
- Common pitfalls:
  - Off-by-one
  - Indexing (0/1)
  - Graph recursion depth
  - Floating errors
  - Mod inverse exists only if gcd=1
  - Negative cycles in shortest path
  - TLE due to python dict overhead

------------------------------------------------------------

# Contest_Execution

## Before Contest
- Warm-up (easy problems / template check)
- Environment setup (editor, snippets, quick run)
- Template sanity check (I/O, mod ops, DS helpers)
- Sleep/energy plan

## During Contest
- Problem scanning (difficulty/constraints)
- Choose solve order (easy-first vs high-value-first)
- Time boxing per problem
- Stop-and-switch rule (avoid tunnel vision)
- Partial scoring strategy (when applicable)
- Write minimal correct solution first, then optimize
- Test quickly on edge cases
- Avoid overengineering early
- Keep track of penalties/time

## After Contest (Most Important)
- Upsolve all unsolved problems
- Read editorials + alternative solutions
- Re-implement from scratch after understanding
- Record mistakes in an error log
- Convert mistakes ‚Üí rules/checklist
- Add problems to spaced repetition set
- Monthly revision of weak topics

